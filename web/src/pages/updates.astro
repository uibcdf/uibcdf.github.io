---
import { getCollection } from 'astro:content';
import BaseLayout from '../layouts/BaseLayout.astro';

const tags = ['all', 'seminar', 'news', 'publication', 'software', 'event', 'opportunity'];

const updates = (await getCollection('updates', ({ data }) => !data.draft)).sort(
  (a, b) => b.data.date.getTime() - a.data.date.getTime()
);
const renderedUpdates = await Promise.all(
  updates.map(async (entry) => {
    const { Content } = await entry.render();
    return { entry, Content };
  })
);
---

<BaseLayout
  title="Updates"
  description="Unified stream for seminars, news, publications, software releases, events, and opportunities."
  ctaLabel="Follow UIBCDF"
  ctaHref="/contact"
>
  <section class="card updates-filters">
    <h2>Search and filter</h2>
    <div class="tag-filters" role="group" aria-label="Update tags">
      {
        tags.map((tag) => (
          <button class:list={['tag-button', tag === 'all' && 'is-active']} type="button" data-filter={tag}>
            {tag}
          </button>
        ))
      }
    </div>
    <div class="updates-advanced-filters" aria-label="Advanced filters">
      <label>
        Search
        <input id="updates-search" type="search" placeholder="Title, summary, keywords..." />
      </label>
      <label>
        From
        <input id="updates-from" type="date" />
      </label>
      <label>
        To
        <input id="updates-to" type="date" />
      </label>
      <button id="updates-clear" type="button" class="tag-button updates-clear">Clear filters</button>
    </div>
    <div class="updates-progress" aria-hidden="true">
      <span class="updates-progress-thumb"></span>
    </div>
  </section>

  {
    renderedUpdates.length === 0 ? (
      <p class="card">No published updates yet.</p>
    ) : (
      <div class="updates-canvas" id="updates-grid">
        {renderedUpdates.map(({ entry, Content }) => {
          const anchorId = `update-${entry.slug.replaceAll('/', '-')}`;
          const bodyText = (entry.body ?? '').trim();
          const hasDetails = bodyText.length > 0;
          const searchBlob = `${entry.data.title} ${entry.data.summary} ${bodyText}`.toLowerCase();
          const entryDate = entry.data.date.toISOString().slice(0, 10);

          return (
            <article
              class="update-card"
              id={anchorId}
              data-tags={entry.data.tags.join(',')}
              data-date={entryDate}
              data-search={searchBlob}
            >
              <div class="update-meta">
                <p>{entryDate}</p>
                {entry.data.tags.length > 0 && (
                  <ul class="tag-list" aria-label="Tags">
                    {entry.data.tags.map((tag) => (
                      <li>{tag}</li>
                    ))}
                  </ul>
                )}
              </div>

              <h2>
                <a href={`#${anchorId}`}>{entry.data.title}</a>
              </h2>
              <p class="update-summary">{entry.data.summary}</p>

              {hasDetails && (
                <details class="update-details">
                  <summary>
                    <span class="summary-closed">Show details</span>
                    <span class="summary-open">Hide details</span>
                  </summary>
                  <div class="update-body">
                    <Content />
                  </div>
                </details>
              )}
            </article>
          );
        })}
      </div>
    )
  }

  <script>
    const shell = document.querySelector('.internal-page-shell');
    const updatesFilters = document.querySelector('.updates-filters');
    const updatesCanvas = document.getElementById('updates-grid');
    const progressRail = document.querySelector('.updates-progress');
    const progressThumb = document.querySelector('.updates-progress-thumb');
    const tagButtons = document.querySelectorAll('.tag-button[data-filter]');
    const cards = document.querySelectorAll('#updates-grid > .update-card');
    const searchInput = document.getElementById('updates-search');
    const fromInput = document.getElementById('updates-from');
    const toInput = document.getElementById('updates-to');
    const clearButton = document.getElementById('updates-clear');
    let hideRaf = null;
    const CUTLINE_OFFSET_PX = 14;

    const state = {
      tag: 'all',
      query: '',
      from: '',
      to: '',
    };

    const getCurrentProgress = () => {
      if (!shell || !updatesCanvas || !updatesFilters) return 0;
      const shellRect = shell.getBoundingClientRect();
      const filtersRect = updatesFilters.getBoundingClientRect();
      const cutoff = filtersRect.bottom + 1 + CUTLINE_OFFSET_PX;
      const cutoffInShell = shell.scrollTop + (cutoff - shellRect.top);
      const canvasTop = updatesCanvas.offsetTop;
      const canvasBottom = canvasTop + updatesCanvas.scrollHeight;
      const ratio = (cutoffInShell - canvasTop) / Math.max(1, canvasBottom - canvasTop);
      return Math.max(0, Math.min(1, ratio));
    };

    const applyFilters = () => {
      const previousProgress = getCurrentProgress();
      cards.forEach((card) => {
        const tagList = (card.getAttribute('data-tags') ?? '').split(',');
        const cardDate = card.getAttribute('data-date') ?? '';
        const cardSearch = card.getAttribute('data-search') ?? '';

        const tagOk = state.tag === 'all' || tagList.includes(state.tag);
        const textOk = state.query.length === 0 || cardSearch.includes(state.query);
        const fromOk = state.from.length === 0 || cardDate >= state.from;
        const toOk = state.to.length === 0 || cardDate <= state.to;

        card.style.display = tagOk && textOk && fromOk && toOk ? '' : 'none';
      });
      requestAnimationFrame(() => {
        scrollToProgress(previousProgress);
        requestHideUpdate();
      });
    };

    const updateProgress = () => {
      if (!shell || !updatesCanvas || !updatesFilters) return;
      const shellRect = shell.getBoundingClientRect();
      const filtersRect = updatesFilters.getBoundingClientRect();
      const cutoff = filtersRect.bottom + 1 + CUTLINE_OFFSET_PX;
      const cutoffInShell = shell.scrollTop + (cutoff - shellRect.top);
      const canvasTop = updatesCanvas.offsetTop;
      const canvasBottom = canvasTop + updatesCanvas.scrollHeight;
      const ratio = (cutoffInShell - canvasTop) / Math.max(1, canvasBottom - canvasTop);
      const clamped = Math.max(0, Math.min(1, ratio));
      updatesFilters.style.setProperty('--updates-progress', clamped.toFixed(4));
    };

    const applyHideByCutline = () => {
      hideRaf = null;
      if (!updatesFilters) return;
      const cutoff = updatesFilters.getBoundingClientRect().bottom + 1 + CUTLINE_OFFSET_PX;
      cards.forEach((card) => {
        if (card.style.display === 'none') {
          card.style.clipPath = '';
          card.style.webkitClipPath = '';
          card.style.opacity = '';
          return;
        }
        const rect = card.getBoundingClientRect();
        const overlap = cutoff - rect.top;
        if (overlap <= 0) {
          card.style.clipPath = '';
          card.style.webkitClipPath = '';
          card.style.opacity = '';
          return;
        }
        if (overlap >= rect.height) {
          card.style.clipPath = `inset(${Math.ceil(rect.height)}px 0 0 0)`;
          card.style.webkitClipPath = `inset(${Math.ceil(rect.height)}px 0 0 0)`;
          card.style.opacity = '0';
          return;
        }
        const clip = Math.max(0, Math.ceil(overlap));
        card.style.clipPath = `inset(${clip}px 0 0 0 round 0.5rem)`;
        card.style.webkitClipPath = `inset(${clip}px 0 0 0 round 0.5rem)`;
        card.style.opacity = '1';
      });
      updateProgress();
    };

    const requestHideUpdate = () => {
      if (hideRaf !== null) return;
      hideRaf = requestAnimationFrame(applyHideByCutline);
    };

    const clamp01 = (value) => Math.max(0, Math.min(1, value));

    const scrollToProgress = (ratio) => {
      if (!shell || !updatesCanvas || !updatesFilters) return;
      const shellRect = shell.getBoundingClientRect();
      const filtersRect = updatesFilters.getBoundingClientRect();
      const cutoffOffset = filtersRect.bottom + 1 + CUTLINE_OFFSET_PX - shellRect.top;
      const canvasTop = updatesCanvas.offsetTop;
      const canvasBottom = canvasTop + updatesCanvas.scrollHeight;
      const range = Math.max(1, canvasBottom - canvasTop);
      const targetCutoffInShell = canvasTop + clamp01(ratio) * range;
      const rawTargetScrollTop = targetCutoffInShell - cutoffOffset;
      const maxScrollTop = Math.max(0, shell.scrollHeight - shell.clientHeight);
      shell.scrollTop = Math.max(0, Math.min(maxScrollTop, rawTargetScrollTop));
    };

    const ratioFromPointer = (clientY) => {
      if (!progressRail || !progressThumb) return 0;
      const railRect = progressRail.getBoundingClientRect();
      const thumbRect = progressThumb.getBoundingClientRect();
      const track = Math.max(1, railRect.height - thumbRect.height);
      const localY = clientY - railRect.top - thumbRect.height / 2;
      return clamp01(localY / track);
    };

    let draggingProgress = false;

    progressRail?.addEventListener('pointerdown', (event) => {
      draggingProgress = true;
      progressRail.classList.add('is-dragging');
      progressRail.setPointerCapture?.(event.pointerId);
      scrollToProgress(ratioFromPointer(event.clientY));
      requestHideUpdate();
      event.preventDefault();
    });

    progressRail?.addEventListener('pointermove', (event) => {
      if (!draggingProgress) return;
      scrollToProgress(ratioFromPointer(event.clientY));
      requestHideUpdate();
      event.preventDefault();
    });

    const stopProgressDrag = (event) => {
      if (!draggingProgress || !progressRail) return;
      draggingProgress = false;
      progressRail.classList.remove('is-dragging');
      progressRail.releasePointerCapture?.(event.pointerId);
    };

    progressRail?.addEventListener('pointerup', stopProgressDrag);
    progressRail?.addEventListener('pointercancel', stopProgressDrag);

    tagButtons.forEach((button) => {
      button.addEventListener('click', (event) => {
        event.preventDefault();
        tagButtons.forEach((item) => item.classList.remove('is-active'));
        button.classList.add('is-active');
        state.tag = button.getAttribute('data-filter') ?? 'all';
        applyFilters();
      });
    });

    searchInput?.addEventListener('input', () => {
      state.query = (searchInput.value ?? '').trim().toLowerCase();
      applyFilters();
    });

    fromInput?.addEventListener('change', () => {
      state.from = fromInput.value ?? '';
      applyFilters();
    });

    toInput?.addEventListener('change', () => {
      state.to = toInput.value ?? '';
      applyFilters();
    });

    clearButton?.addEventListener('click', () => {
      state.tag = 'all';
      state.query = '';
      state.from = '';
      state.to = '';
      if (searchInput) searchInput.value = '';
      if (fromInput) fromInput.value = '';
      if (toInput) toInput.value = '';
      tagButtons.forEach((item) => item.classList.remove('is-active'));
      const allButton = document.querySelector('.tag-button[data-filter="all"]');
      allButton?.classList.add('is-active');
      applyFilters();
    });

    shell?.addEventListener('scroll', requestHideUpdate, { passive: true });
    window.addEventListener('resize', requestHideUpdate);
    requestHideUpdate();
  </script>
</BaseLayout>

<style is:global>
  :root {
    --internal-flat-bg: #e4e9ef;
  }
</style>
